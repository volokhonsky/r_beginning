---
title: "АНАЛИЗ ДАННЫХ В СОЦИАЛЬНЫХ НАУКАХ С ПОМОЩЬЮ ЯЗЫКА R"
output: 
  ioslides_presentation:
    self_contained: yes
    incremental: true
    widescreen: true
---




# Продолжим!



## Формат файла .Rdata

В R есть свой собственный формат данных, в котором можно сохранить коллекцию R объектов или "слепок" сразу всего Workspace.

Давайте сделаем свой файл load.R


```{r}
#это файл с загрузкой данных!
data<-read.table(file="data/iGLAS for R course.csv",sep=",", 
                  quote = "\"", header=T,fileEncoding = "UTF-8-BOM")
five_point_scales<-grep("i5",names(data),value = T) 
save(data,five_point_scales,file="data/iGLAS.Rdata")

```
Вот это вот запишите в новый файл load.R, сохранив его в корневой папке проекта. 

## Как удалить вообще всё из памяти

1) Кнопка-метёлка в окне Environment
2) Команда *rm(list=ls())*
3) Перезапустить R через Session -> Terminate R

##

А теперь, после того, как всё удалили, просто загрузите данные из записанного файла:

```{r}
load("data/iGLAS.Rdata")
```
А ещё, можно запускать код любого другого R-скрипта через команду source:
```{r eval=F}
source("load.R")
```
Если вы исполняете такой файл, результаты его исполнения сохраняются в памяти и вам не нужны промежуточные файлы. 

## Внимание, вопрос:

### Так зачем же сохранять промежуточные файлы .Rdata?


## целые числа 
Сегодня мы продолжим изучение различных типов данных в R. 

Начнём с целых чисел. 
Ограничения на целочисленные выражения.
Подробнее документацию можно изучить, запустив команды ?integer и ?double.

```{r eval=FALSE}

int_num<-c(1,2,3,4000)
int_num<-as.integer(c(1,2,3,4000))
as.integer(214748364.7)
as.integer(2147483648)
as.integer(-2147483647)
as.integer(-2147483648)
as.double("10000998843483274893274892374238947273")
options(scipen=100)
2^64
90071992547409923
100000000/20000000
```


## числа с десятичной долей (double)

```{r eval=F}

numeric_num<-c(1,2,2.5)
is.integer(numeric_num)
is.integer(int_num)
is.numeric(int_num)
is.numeric(numeric_num)
str(numeric_num)
is.double(numeric_num)
typeof(numeric_num)
class(numeric_num)
```

## Генерирование случайных чисел

Континуальные числа:

```{r}
#равномерное распределение:
unif<-runif(100)  
unif<-runif(100,min = 0,max=100)  
#нормальное:
norm<-rnorm(100)
norm<-rnorm(100000,mean = 50,sd = 10)
```
##
```{r}
hist(norm)
```

## 
Дискретные числа: 

```{r}
sample(x = 1:100,size = 10)
sample(1:2,10,replace = T)
sample(10,2)

```


## shuffle вектора

Если на вход sample подать просто вектор, то size по умолчанию равен длине этого вектора. Получится тот же вектор, но случайным образом перемешанный. 

```{r}
sample(LETTERS[1:3]) #LETTERS - встроенный в базовый R вектор-заготовка с буквами английского алфавита
```

##
Ещё немного про генерацию данных...

```{r}
#команда rep - очень удобная штука... 
 
rep(c(1:3),times=3)
rep(1:3,each=3)
rep(1:2,times=2,each=2)
```
##
```{r}
#удобная команда seq

seq(from = 1,to = 20,by = 2)

#враппер
seq_len(10)
```




## Базовые операции с числовыми векторами

```{r}
mean(norm,na.rm = T)
median(norm,na.rm=T)
sd(norm,na.rm=T)
max(norm,na.rm=T)
```
##
```{r}
min(norm,na.rm=T)
length(norm) # но это к любому объекту применимо
length(data)

```

## Разрежем наш вектор! 
Обратите внимание на такие аргументы, как right и include.lowest. Они дают несколько вариантов действий с теми значениями, которые попадают строго на границу интервалов. В случае переменных границ интервалов лучше использовать Inf и -Inf в качестве крайних границ диапазонов. Количество диапазонов равно количеству границ минус один. 

```{r eval=F}
a<-c(1:5)
cut(a,breaks = c(2,4))
cut(a,breaks = c(-Inf,3,Inf))
cut(a,breaks = c(-Inf,3,Inf),right = F)
```

##

Уровням можно присваивать имена!

```{r}
a<-c(1:5)
cut(a,breaks = c(-Inf,2,4,Inf),right = F,labels = c("l","m","h"))
```

## А теперь - процентиль!

Вернее - квантиль. Эти свойства распределения в паре с командой cut удобно использовать для того, чтобы изменять распределение. Например, [нелинейная нормализация](https://en.wikipedia.org/wiki/Sten_scores). 
```{r}
quantile(norm,c(0.1,0.5,0.9))

```









## Факторы
Вот то, что было результатом выполнения команды cut - это был фактор! Факторы - это закодированные упорядоченные значения уровней фактора. По умолчанию уровни фактора расставляются по алфавиту.  
Можно менять порядок уровней:

```{r}
a<-factor(c("плохо","так себе","так себе","хорошо","отлично","отлично"))
levels(a)
fl<-c("плохо","так себе","хорошо","отлично")
a<-factor(a,levels=fl)
levels(a)
```
##

Можно перекодировать значения переменных, просто заменяя вектор уровней фактора:

```{r}
levels(a)<-c("тошнотворно", "отвратительно", "так себе", "сойдёт")
a
```
Более того, можно уровни фактора объединять в один:
```{r}
levels(a)<-c("тошнотворно", "тошнотворно", "тошнотворно", "сойдёт")
a
```
##

Числовой вектор тоже можно превратить в фактор:

```{r}
num<-c(1,1,2,3,3,1,5,4,2)
num<-factor(num)
```
После этого можно ввести расшифровку этих уровней:

```{r}
levels(num)<-c("Strongly disagree",
"Disagree",
"Neither agree nor disagree",
"Agree",
"Strongly agree")
num
```





##

Факторы могут быть упорядоченными (как ранговая шкала):

```{r}
a<-factor(a,ordered=T)
str(a)
```

##

очень неприятный случай, которого лучше избегать - преобразование в количественную шкалу фактора, созданного и смеси текста и чисел:


```{r}
a<-factor(c("0","нет ответов","1","2","3"))
levels(a)
as.character(a)
as.numeric(a)

```


##

Чтобы с этим справиться, надо сперва фактор преобразовать в character, а уж потом в numeric.

```{r}
as.numeric(as.character(a))
```

И препятствовать появлению факторов при импорте файла:

```{r}
data<-read.table(file="data/iGLAS for R course.csv",sep=",", 
                  quote = "\"", header=T,fileEncoding = "UTF-8-BOM")
data2<-read.table(file="data/iGLAS for R course.csv",sep=",", 
                  quote = "\"", header=T,fileEncoding = "UTF-8-BOM",
                  stringsAsFactors = F)



```

##

Посмотрим, какова разница между датафреймом с факторами и с простыми строками:

```{r}
object.size(data)
object.size(data2)
```

## Строки



```{r}
a<-c("мыла","мама", "раму")
typeof(a)

```

Операции сравнения возможны и со строками!

```{r}
a[a>"мы"]
a[a=="мыла"]

```

##

Практическая польза! 
```{r}
b<-c("2018-07-25","2018-07-28")
b < "2018-07-26"
```

```{r}
dates<-c("2017-07-26","2017-07-29","2017-08-20","2016-06-30","2017-02-29")

dates[dates<"2017-07-27"]


```
##

Строки можно объединять с помошью paste. Векторов может быть много! 


```{r}
a<-LETTERS[1:10]
b<-1:10
c<-1:5
paste(a,b,c,sep="$")
paste("var_",b,sep="")

```

##
Слияние всех элементов вектора - через collapse:

```{r}
paste(a,collapse="")
paste(a,collapse=" ")

```


## логические векторы
Повторение - мать учения. :-)

```{r eval=FALSE}
a<-c(T,F,F,F,T,NA)
which(a)
which(!a)
```

Чаще всего логические векторф используются для фильтрации

```{r}
v<-c("мама", "мыла", "раму", "мыла", "было", "мало")
v[a]
```
Обратите внимание на NA.  Если в логическом векторе есть пропуски, то фильтровать им нельзя! 

## логические векторы

Зато можно так:

```{r}
v<-c("мама", "мыла", "раму", "мыла", "было", "мало")
a<-c(T,F,F,F,T,NA)
v[which(a)]
```
В R действует одновременно три разных способа фильтрации объектов:

1. с помощью вектора с адресами (номерами строк)
2. с помощью вектора с именами
3. С помощью логического вектора

##

Списки и датафреймы
```{r}

u=list("A", 1, list ("A", T))
str(u) #обратите внимание на str - команда показывает структуру данных

uu<-c(list("a",5),list(list(5)))
unlist(u)

u<-list("a"=c(1,2),"b"=c(3,4))
u2<-as.data.frame(u)
```

## Адресация в списках

```{r}
u=list("A", 1, list ("A", T))
#как обратитьcя, чтобы получить T? 
u[[3]][[2]]
#в чём разница [[]] и []?
str(u[1])
str(u[[1]])
```



##

Задание для самостоятельной работы:

1. Вспомните всё про факторы. В ваших данных есть переменная data$iDgender. Превратите её в фактор со значениями согласно документации опроса. 
2. Создайте файл clean.R и включите в него код c предыдущего занятия, в котором заменяли возраст старше 95 лет на пропуски. Перед этим там надо загрузить данные из сохранённого сегодня файла .Rdata
3. Создайте файл analyze_age.R и из него запустите clean.R
Следующие два задания делайте в нём. 
4. Вспомните про фильтрацию с помощью логических векторов. Посчитайте средний возраст для мужчин и для женщин отдельно. 
5. Разбейте возраст на три группы по 25 и 75 процентилю, создав переменную data$age_group c именами групп "young", "middle", "old".

продолжение на следующей странице!

##

6. Создайте переменную x, которая будет содержать данные, составляющие следующий ряд (заполнить пропущенное):

"10a","15b","20c","25a","30b", ..., "200c"

Проверка: 

sum(strtoi(x,16))==138141
  
7.  Создайте переменную, которая будет содержать данные, составляющие следующий ряд (заполнить пропущенное):

  "1207a" "1327b" "1448c" "1568a" "1689b" "1809c" "1927a" "2047b" "2168c" "2288a" "2409b" ... "4689c"  
Проверка: 
sum(strtoi(x,16))==5417034

Нет, тут нет опечаток :-)


